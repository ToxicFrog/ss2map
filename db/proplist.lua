-- Library for reading the proplist.txt generated by :dump_props_full
--
-- Note that there are two different kinds of proplist; the one generated by
-- plain :dump_props is not supported!
--
-- Load your proplist file with proplist.load('proplist.txt') to get a proplist
-- object. This then exposes one function, plist:read(key, data); it will
-- deserialize the data and return a

-- Notes on proplist.txt structure
-- Your typical property definition looks like this:
--[[
    ObjProp "BaseStatsDesc"  // type sStatsDesc   , flags 0x000, editor name: "Player: Base Stats"
    {
      "STR": int
      "END" int
      "PSI: int
      ...and so on...
    }
--]]
-- If the property only has one field, it may have a name or may just be named
-- "", and we can treat it as a scalar. If it has more than one field, they will
-- all be named. Unfortunately, the order they appear in IS NOT guaranteed to
-- match the order they appear on disk, so any aggregate-type property requires
-- special handling.
-- TODO: handle aggregates. At the moment we just emit placeholders for them.
--
-- Field names are not guaranteed to be valid Lua identifiers; they may contain
-- spaces, punctuation, etc.
--
-- In addition, enum fields will have something that looks like this:
--[[
    "Effect" : enum // enums: "Normal", "No Effect", "Terminate", "Destroy"
--]]
-- where the comment lists the meaning of the possible enum values. Similarly,
-- bitmask fields will look like this:
--[[
    "" : bitflags // flags: "Once Grunt Organ", "Spore Organ", "Midwife Organ", ....
]]
-- with the comment listing the name of each bit, presumably LSB first.

local vstruct = require 'vstruct'
local proplist = {}
proplist.__index = proplist

-- Load a proplist.txt from disk and return a plist object.
function proplist.load(file)
  return proplist.parse(assert(io.open(file, 'rb')):read('*a'))
end

local formats = {
  ang = 'p2,15'; -- assuming it's the same as in brushes...
  bitflags = 'u4';
  bool = 'b4';
  enum = 'u4';
  float = 'f4';
  int = 'i4';
  int_hex = 'i4';
  rgb = '{ r:u1 g:u1 b:u1 }';
  sfloat = 'u2'; -- TODO: 16-bit floats
  short = 'i2';
  -- TODO: strings are a mess; some are c4, some are c4 null terminated, some are z with a fixed buffer size??
  string = 'x4 z';
  uint = 'u4';
  uint_hex = 'u4';
  ushort = 'u2';
  vector = '{ x:f4 y:f4 z:f4 }';
}

local function mungeKey(key)
  return key:gsub('%W+', '_'):gsub('_+$', ''):gsub('^_+', ''):gsub('^(%d)', '_%1')
end

local function parseBody(self, body)
  local buf = {}
  for name,type,tail in body:gmatch('"(.-)"%s*:%s*(%S+)(.-)\n') do
    table.insert(buf, {key = name, format = assert(formats[type], type)})
  end
  if #buf == 1 then
    -- only one field!
    self.format = vstruct.compile(buf[1].format)
    self.unpack = true
  else
    -- Turns out the field list in proplist.txt is not guaranteed to be in the
    -- correct order, RIP.
    -- For now just pass through the data.
    -- for i,field in ipairs(buf) do
    --   buf[i] = mungeKey(field.key)..':'..field.format
    -- end
    -- self.format = vstruct.compile(table.concat(buf, ' '))
  end
end

local propdef_matcher = string.gsub(
  'ObjProp "(.-)" // type (%S+) , flags 0x(%x+)(.-)(%b{})',
  ' ', '%%s+')

function proplist.parse(buf)
  local self = {
    _propdefs = {}
  }
  setmetatable(self, proplist)
  for name,ctype,flags,tail,body in buf:gmatch(propdef_matcher) do
    local propdef = {
      name = name;
      ctype = ctype;
      flags = tonumber(flags, 16); -- TODO: figure out what all the flags mean
      editor_name = tail:match('editor name: "(.-)"');
    }
    parseBody(propdef, body)
    -- tagfiles only store the first nine bytes of the name
    self._propdefs[name:sub(1,9)] = propdef
  end
  return self
end

function proplist:read(name, buf)
  local prop = self._propdefs[name]
  if not prop or not prop.format then
    return  '[unknown: '..#buf..' bytes]';
  elseif prop.unpack then
    return table.unpack(prop.format:read(buf))
  else
    return prop.format:read(buf)
  end
end

return proplist


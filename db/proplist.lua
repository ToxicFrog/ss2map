-- Library for reading the proplist.txt generated by :dump_props_full
--
-- Note that there are two different kinds of proplist; the one generated by
-- plain :dump_props is not supported!
--
-- Load your proplist file with proplist.load('proplist.txt') to get a proplist
-- object. This then exposes one function, plist:read(key, data); it will
-- deserialize the data and return a

-- Notes on proplist.txt structure
-- Your typical property definition looks like this:
--[[
    ObjProp "BaseStatsDesc"  // type sStatsDesc   , flags 0x000, editor name: "Player: Base Stats"
    {
      "STR": int
      "END" int
      "PSI: int
      ...and so on...
    }
--]]
-- If the property only has one field, it may have a name or may just be named
-- "", and we can treat it as a scalar. If it has more than one field, they will
-- all be named. Unfortunately, the order they appear in IS NOT guaranteed to
-- match the order they appear on disk, so any aggregate-type property requires
-- special handling.
-- TODO: handle aggregates. At the moment we just emit placeholders for them.
--
-- Field names are not guaranteed to be valid Lua identifiers; they may contain
-- spaces, punctuation, etc.
--
-- In addition, enum fields will have something that looks like this:
--[[
    "Effect" : enum // enums: "Normal", "No Effect", "Terminate", "Destroy"
--]]
-- where the comment lists the meaning of the possible enum values. Similarly,
-- bitmask fields will look like this:
--[[
    "" : bitflags // flags: "Once Grunt Organ", "Spore Organ", "Midwife Organ", ....
]]
-- with the comment listing the name of each bit, presumably LSB first.

local vstruct = require 'vstruct'
local ptypes = require 'proptypes'
local proplist = {}
proplist.__index = proplist

-- Load a proplist.txt from disk and return a plist object.
function proplist.load(file)
  return proplist.parse(assert(io.open(file, 'rb')):read('*a'))
end

local formats = {
  ang = 'p2,15'; -- assuming it's the same as in brushes...
  bitflags = 'u4';
  bool = 'b4';
  enum = 'u4';
  float = 'f4';
  int = 'i4';
  int_hex = 'i4';
  rgb = '{ r:u1 g:u1 b:u1 }';
  sfloat = 'u2'; -- TODO: 16-bit floats
  short = 'i2';
  -- TODO: strings are a mess; some are c4, some are c4 null terminated, some are z with a fixed buffer size??
  string = 'x4 z';
  uint = 'u4';
  uint_hex = 'u4';
  ushort = 'u2';
  vector = '{ x:f4 y:f4 z:f4 }';
}

local function mungeKey(key)
  return key:gsub('%W+', '_'):gsub('_+$', ''):gsub('^_+', ''):gsub('^(%d)', '_%1')
end

local function parseBody(self, body)
  local buf = {}
  local ptype = ptypes[self.ctype]
  if ptype then
    self.format = ptype.format
    self.pprint = ptype.pprint
    self.dtype = self.ctype
    return
  end

  for name,type,tail in body:gmatch('"(.-)"%s*:%s*(%S+)(.-)\n') do
    local field = {
      key = name;
      format = assert(formats[type], 'Unknown property field type '..type);
      ctype = type;
    }
    if type == 'enum' then
      field.enum = {}
      local i = 0
      for name in (tail..','):gmatch('"(.-)",') do
        field.enum[i] = name
        i = i+1
      end
    elseif type == 'bitflags' then
      -- parse tail
    else
      -- generic deserializer
    end
    table.insert(buf, field)
  end
  if #buf == 1 then
    -- only one field!
    self.enum = buf[1].enum
    self.format = vstruct.compile(buf[1].format)
    self.unpack = true
    self.dtype = buf[1].ctype
  else
    -- Turns out the field list in proplist.txt is not guaranteed to be in the
    -- correct order, RIP.
    -- For now just pass through the data.
    -- for i,field in ipairs(buf) do
    --   buf[i] = mungeKey(field.key)..':'..field.format
    -- end
    -- self.format = vstruct.compile(table.concat(buf, ' '))
    self.dtype = 'unknown'
  end
end

local propdef_matcher = string.gsub(
  'ObjProp "(.-)" // type (%S+) , flags 0x(%x+)(.-)(%b{})',
  ' ', '%%s+')

function proplist.parse(buf)
  local self = {
    _propdefs = {}
  }
  setmetatable(self, proplist)
  for key,ctype,flags,tail,body in buf:gmatch(propdef_matcher) do
    local propdef = {
      key = key:sub(1,9); -- tagfiles only store the first nine bytes
      key_full = key;
      name = tail:match('editor name: "(.-)"');
      ctype = ctype;
      flags = tonumber(flags, 16); -- TODO: figure out what all the flags mean
    }
    parseBody(propdef, body)
    self._propdefs[propdef.key] = propdef
  end
  return self
end

local printer = {}
function printer.vector(self)
  return '(%.2f, %.2f, %.2f)' % { self.value.x, self.value.y, self.value.z }
end
function printer.bitflags(self)
  return '[bitfield: %08X]' % self.value
end
function printer.enum(self)
  assert(self.enum, 'no enum definition for '..self.key_full)
  return self.enum[self.value] or '[enum: %d]' % self.value
end
function printer.ang(self)
  return '%dÂ°' % (self.value * 180)
end
function printer.rgb(self)
  return '#%02X%02X%02X' % { self.value.r, self.value.g, self.value.b }
end
function printer.int_hex(self)
  return '%x' % self.value
end
function printer.uint_hex(self)
  return '%x' % self.value
end
function printer.unknown(self)
  return 'Unknown: '..(self.value:gsub(".", function(c) return ("%02X "):format(c:byte()) end):sub(1,-2))
end
function printer.default(self) return tostring(self.value) end

local function generic_pprint(self)
  if printer[self.dtype] then
    return printer[self.dtype](self)
  else
    return printer.default(self)
  end
end

function proplist:read(name, buf)
  local propdef = self._propdefs[name]
  if not propdef then
    return {
      name = '[unknown %s]' % name;
      key = name; key_full = '?'..name..'?';
      value = buf;
      pprint = generic_pprint;
      dtype = 'unknown';
    }
  elseif not propdef.format then
    return {
      name = propdef.name;
      key = propdef.key; key_full = propdef.key_full;
      value = buf;
      pprint = generic_pprint;
      dtype = 'unknown';
    }
  end

  local value = propdef.format:read(buf)
  if propdef.unpack then
    value = table.unpack(value)
  end
  return {
    name = propdef.name;
    key = propdef.key; key_full = propdef.key_full;
    value = value;
    pprint = propdef.pprint or generic_pprint;
    dtype = propdef.dtype;
    enum = propdef.enum;
  }
end

return proplist


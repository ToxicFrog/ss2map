-- Library for reading the proplist.txt generated by :dump_props_full
--
-- Note that there are two different kinds of proplist; the one generated by
-- plain :dump_props is not supported!
--
-- This should be used as part of the broader db interface, via db:load_proplist().

-- Notes on how properties are stored internally.
--
-- A single property field is represented by a ptype, defined in proptypes.lua.
-- This holds three functions:
-- - parseTail, called at parse time to specialize enum and bitfield ptypes
-- - read, which deserializes the property value from a data buffer
-- - pprint, which returns a human-readable string of the property value
--
-- A property *definition* links a name to a ptype; it is a table containing:
-- - key (9-character property key used in the tagfile)
-- - key_full (property key without truncation)
-- - name (human-readable "editor name")
-- - ctype (name of the property type as declared in the proplist.txt)
-- - ptype (top-level ptype of the property)
--
-- Properties held in objects are very simple tables that just look like:
--   { value = value; propdef = propdef; obj = obj; }
-- where obj points to the containing object. A metatable supplies access to
-- property methods like pprint().

-- Notes on proplist.txt structure
-- Your typical property definition looks like this:
--[[
    ObjProp "BaseStatsDesc"  // type sStatsDesc   , flags 0x000, editor name: "Player: Base Stats"
    {
      "STR": int
      "END" int
      "PSI: int
      ...and so on...
    }
--]]
-- If the property only has one field, it may have a name or may just be named
-- "", and we can treat it as a scalar. If it has more than one field, they will
-- all be named. Unfortunately, the order they appear in IS NOT guaranteed to
-- match the order they appear on disk, so any aggregate-type property requires
-- special handling.
-- TODO: handle aggregates. At the moment we just emit placeholders for them.
--
-- Field names are not guaranteed to be valid Lua identifiers; they may contain
-- spaces, punctuation, etc.
--
-- In addition, enum fields will have something that looks like this:
--[[
    "Effect" : enum // enums: "Normal", "No Effect", "Terminate", "Destroy"
--]]
-- where the comment lists the meaning of the possible enum values. Similarly,
-- bitmask fields will look like this:
--[[
    "" : bitflags // flags: "Once Grunt Organ", "Spore Organ", "Midwife Organ", ....
]]
-- with the comment listing the name of each bit, presumably LSB first.

local ptypes = require 'proptypes'
local proplist = {}
proplist.__index = proplist

-- Load a proplist.txt from disk and return a plist object.
function proplist.load(file)
  return proplist.parse(assert(io.open(file, 'rb')):read('*a'))
end

local function mungeKey(key)
  return key:gsub('%W+', '_'):gsub('_+$', ''):gsub('^_+', ''):gsub('^(%d)', '_%1')
end

local function parseBody(propdef, body)
  local ptype = ptypes[propdef.ctype]
  if ptype then
    -- We have a proptype definition that covers this property in its entirety,
    -- so just use that.
    propdef.ptype = ptype
    return
  end

  -- Parse the body and extract fields from it.
  for name,type,tail in body:gmatch('"(.-)"%s*:%s*(%S+)(.-)\n') do
    if propdef.ptype then
      -- Uh-oh, ptype already set? We've already processed one field, which means
      -- this is a multifield property, and we can't handle those because the field
      -- order in proplist.txt doesn't match the on-disk format.
      propdef.ptype = ptypes.unknown
      return
    end

    local ptype = ptypes[type]
    if not ptype then
      -- Contains a field we don't know how to deserialize.
      propdef.ptype = ptypes.unknown
      return
    end

    local field = ptype:clone()
    field.name = name;
    field:parseTail(tail)
    propdef.ptype = field
  end
end

local propdef_matcher = string.gsub(
  'ObjProp "(.-)" // type (%S+) , flags 0x(%x+)(.-)(%b{})',
  ' ', '%%s+')

function proplist.parse(buf)
  buf = buf:gsub('\r\n', '\n')
  local self = {
    _propdefs = {}
  }
  setmetatable(self, proplist)
  for key,ctype,flags,tail,body in buf:gmatch(propdef_matcher) do
    local propdef = {
      key = key:sub(1,9); -- tagfiles only store the first nine bytes
      key_full = key;
      name = tail:match('editor name: "(.-)"');
      ctype = ctype;
      flags = tonumber(flags, 16); -- TODO: figure out what all the flags mean
    }
    parseBody(propdef, body)
    self._propdefs[propdef.key] = propdef
  end
  return self
end

-- Universal methods available on all properties
local property = {}
function property:__index(key)
  return self.propdef[key] or property[key]
end
function property:__tostring()
  return 'ObjProp[%s]' % self.propdef.key_full
end
function property:pprint()
  return self.propdef.ptype:pprint(self.value)
end

function proplist.wrap(v)
  return setmetatable(v, property)
end

local function mkUnknownPropdef(name)
  return {
    name = '[unknown %s]' % name;
    key = name; key_full = '?'..name..'?';
    ptype = ptypes.unknown;
  }
end

function proplist:read(name, buf)
  local propdef = self._propdefs[name]
  if not propdef then
    propdef = mkUnknownPropdef(name)
  end

  local value = propdef.ptype:read(buf)

  return proplist.wrap { propdef = propdef; value = value; }
end

return proplist
